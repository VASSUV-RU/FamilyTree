# Авторизация

Документ описывает процесс входа в систему, управление сессиями и выдачу прав.

Зависимости: используется Redis для хранения серверных сессий и блок‑листа (`sess:{jti}`, `blk:{jti}`) и защиты от повторов (`used_hash:{hash}`).

## 1. Термины

- **access-JWT** — короткоживущий JWT, содержащий `sub`, `jti`, `iat`, `exp`.
- **refresh-токен** — токен, возвращаемый в `AuthResponse` и используемый для получения нового access-JWT.
- **jti** — идентификатор сессии; используется в ключах `sess:{jti}` и `blk:{jti}`.
- **capVersion** — версия прав пользователя для синхронизации и проверки актуальности.
- **scopes** — перечень permissions, применимых для активной семьи; термин scopes в ответах API равнозначен permissions.

Подробнее о ролях и правах: см. [roles](../../reference/roles.md), [permissions](../../reference/permissions.md).

## 2. Цели

- Выдать короткоживущий access-JWT.
- Создать/обновить серверную сессию в кеше (`sess:{jti}` с TTL ≈ время жизни access + δ).
- Вернуть клиенту набор прав по активной семье.
- Минимизировать содержимое JWT.

## 3. Сценарии входа

### 3.1 Вход через Telegram‑бот (deep‑link, асинхронно)
1. Фронт запрашивает создание «ожидающей сессии»: `POST /auth/telegram/session` (опц. передаёт `invitationId`).
2. Бэкенд возвращает `sid` и deep‑link `https://t.me/{bot}?start={sid}` (payload ≤ 64 байт).
3. Пользователь кликает ссылку, в Telegram нажимает Start/Confirm.
4. Telegram шлёт webhook на наш сервер (`POST /telegram/webhook`), бот‑хендлер видит `/start <sid>` и вызывает внутренний сервис подтверждения (без отдельного HTTP‑вызова).
5. Бэкенд помечает `sid` как подтверждённый, создаёт/обновляет пользователя и сессию, при наличии инвайта — принимает его и определяет активную семью.
6. Фронт вызывает `GET /auth/telegram/session/{sid}` и ожидает до таймаута. При готовности сервер возвращает `AuthResponse` c `accessToken` и `refreshToken`.

Варианты:
- Новый владелец семьи — `invitationId` не передан: создаётся семья, роль `owner`.
- Новый приглашённый — `invitationId` привязан к `sid`: создаётся учётка и членство с указанной ролью.
- Существующий пользователь — обновляется сессия, активная семья берётся последняя или выбирается отдельно.

### 3.2 Обновление access по refresh‑токену
Клиент передаёт refresh‑токен в теле запроса; сервер выдаёт новый access‑JWT и ротирует `jti`.

### 3.3 Смена активной семьи
Пользователь переключает контекст на другую семью, права пересчитываются без повторной аутентификации.

### 3.4 Выход
Сессия удаляется, `jti` помещается в `blk:{jti}` до истечения срока.

## 4. Контракты API

Ответы ошибок имеют вид:

```json
{ "error": "CODE", "message": "Описание" }
```

### 4.1 `POST /auth/telegram/session`
Создаёт «ожидающую сессию» и возвращает deep‑link для старта в Telegram.

Тело запроса (опционально):

```json
{ "invitationId": "inv-123" }
```

Успешный ответ:

```json
{ "sid": "Sabc123", "deeplinkUrl": "https://t.me/bot?start=Sabc123", "expiresIn": 300 }
```

Ошибки: `429 TOO_MANY_ATTEMPTS`.

### 4.2 `GET /auth/telegram/session/{sid}`
Ожидает подтверждение «ожидающей сессии» и при готовности возвращает `AuthResponse`.

Ответ (ожидание/таймаут):

```json
{ "status": "pending" }
```

Ответ (успех):

```json
{ "status": "ready", "auth": { "accessToken": "...", "refreshToken": "..." } }
```

Ошибки: `404 NOT_FOUND`, `410 GONE` (истёк), `409 ALREADY_USED`.

—
Webhooks

Обработка подтверждения выполняется в хендлере Telegram‑webhook (например, `POST /telegram/webhook`) в рамках того же приложения. Рекомендуется включить секретный заголовок Telegram (`X-Telegram-Bot-Api-Secret-Token`) и проверку источника.

### 4.3 `POST /auth/refresh`
Выдаёт новый access-JWT по refresh-токену, создаёт `sess:{jtiNew}` и добавляет старый `jti` в `blk:{jtiOld}`.

Запрос:

```json
{ "refreshToken": "..." }
```

Пример ответа идентичен `POST /auth/telegram/verify`.

### 4.4 `POST /me/active-family`
Переключает активную семью.

Запрос:

```json
{ "familyId": "f-789" }
```

Ответ:

```json
{
  "accessToken": "jwt",
  "expiresIn": 900,
  "activeFamilyId": "f-789",
  "scopes": ["media:list","media:download"]
}
```

Ошибки: `403 NO_MEMBERSHIP`, `404 FAMILY_NOT_FOUND`.

### 4.5 `POST /auth/logout`
Удаляет текущую сессию и помещает `jti` в `blk:{jti}`.

Ответ `204 No Content`.

## 5. Алгоритм подтверждения через бота

1. Создать «ожидающую сессию» с `sid` (TTL ~ 5 минут), опционально привязать `invitationId`.
2. Бот получает `/start <sid>` и обращается к бэкенду с `POST /internal/bot/telegram/confirm`.
3. Проверить заголовок секрета для webhook/интеграции бота (например, `X-Telegram-Bot-Api-Secret-Token`).
4. Проверить, что `sid` существует, не истёк и не использован.
5. Найти или создать пользователя по `telegramId`.
6. Определить активную семью: принять инвайт, если он связан с `sid`, либо создать новую семью (для онбординга владельца).
7. Сгенерировать `jti`, записать `sess:{jti}` и подготовить `AuthResponse` для выдачи на фронт при опросе `GET /auth/telegram/session/{sid}`; вернуть refresh-токен в ответе.

## 6. Структура access-JWT

Пример содержимого:

```json
{
  "sub": "u-123",
  "jti": "sess-abc",
  "iat": 1734970000,
  "exp": 1734970900
}
```

JWT подписывается `RS256` или `ES256`, размер — не более 2 КБ. При каждом запросе проверяются подпись и срок действия. По `jti` ищется `sess:{jti}` в Redis; при отсутствии выполняется одно резервное обращение к БД.

## 7. Поток обновления токена

Refresh-токен возвращается в `AuthResponse` и хранится на клиенте (например, в зашифрованном сторадже приложения). Для обновления access-JWT клиент отправляет `POST /auth/refresh` с телом `{ "refreshToken": "..." }`.

1. Проверяется валидность и отзыв refresh-токена.
2. Генерируется новый `jti` и новый access-JWT.
3. `sess:{jti}` пересоздаётся из `perm:{userId}:{familyId}`.
4. Старый `jti` добавляется в `blk:{jtiOld}` до истечения `exp`.

При утрате refresh-токена требуется повторный вход через Telegram.

## 8. Смена активной семьи

1. Проверить, что у пользователя есть членство в `familyId`.
2. Загрузить пресеты прав из БД и обновить `perm:{userId}:{familyId}`.
3. Обновить `sess:{jti}` (активная семья, права, `capVersion`) и выдать новый access-JWT.

## 9. Обновление прав в реальном времени

- **Push-оповещение**: при изменении ролей система находит активные `jti` пользователя и обновляет соответствующие `sess:{jti}`.
- **Ленивая проверка**: при запросе сравнивается локальный `capVersion` с версией в `sess:{jti}`; при расхождении сессия пересобирается.

## 10. Безопасность и ограничения

- Ограничение частоты на `/auth/telegram/verify`, например 5 попыток в минуту на IP или `telegram_id`.
- Защита от повторов: окно для `auth_date` и одноразовость набора данных (`used_hash:{hash}` с TTL несколько минут).
- Аудит: логирование успешных и неуспешных входов, смены семьи, обновлений и выходов в централизованном журнале.
- При отказе кэша допускается одно резервное обращение к БД, затем возврат `503` или `403`.
- CORS/CSRF: access передаётся в заголовке `Authorization`; обновление — через refresh-токен в теле запроса и при необходимости токен двойной отправки.

## 11. Открытые вопросы

- Окно допустимого `auth_date`.
- TTL access-JWT.
- Стратегия ротации refresh-токена.
- Выбор первой активной семьи.
- Механизм хранения индекса `index:user:{userId} → [jti...]` для массового отзыва.

Приглашаем команду к обсуждению этих пунктов.

## 12. Сущность User (авторизация)

Сущность `User` описана в [reference/entities/user.md](../../reference/entities/user.md).

Ключевые моменты для авторизации:
- Права и роли выводятся из `Member` активной семьи (см. [roles](../../reference/roles.md), [permissions](../../reference/permissions.md)).
- Привязка к узлу дерева выполняется через `Member.personId` (см. [identity](../../reference/entities/identity.md)).
