# 01 — Создание пользователя при подтверждении Telegram‑авторизации

Цель
- При подтверждении `sid` создавать или обновлять `User`, чтобы весь последующий функционал семьи имел базовую учётку.

Требования
- Добавить модель `UserEntity` в модуле `app/data` (таблица `users`), репозиторий и mapper в `app/service`.
- Поля: `id` (ULID/UUID), `name`, `avatarUrl?`, `telegramId?`, `createdAt`, `preferredFamilyId?`.
- Обеспечить уникальность `telegram_id` (индекс + валидация). При конфликте возвращать `conflictError()`.
- Реализовать сервис `UserService.upsertFromTelegram(telegramId, name, avatarUrl?)` в модуле `app/service`: 
  - новый пользователь → генерировать `id`, `createdAt`, `preferredFamilyId = null`;
  - существующий → обновлять изменившиеся поля без перезаписи `createdAt`.
- В обработчике подтверждения Telegram (`app/application` или `app/bot-telegram`) подключить сервис и получать `User` до выполнения логики семьи.
- Согласовать схему с Liquibase (миграция `users` + индекс по `telegram_id`).

Интеграция
- Метод возвращает `User` для последующей передачи в шаги 02/03 (создание семьи или членства).
- Сохранённый `User.id` используется как `ownerId`/`userId` в таблицах семьи.

Приёмочные критерии
- Новый Telegram-пользователь после подтверждения получает запись в таблице `users`.
- Повторное подтверждение того же `telegramId` обновляет только имя/аватар.
- Конфликт по `telegramId` приводит к `409 Conflict` через хендлер исключений.

Тест‑идеи
- Unit `UserService`: новый user → сохраняется с ожиданием значений; существующий → update.
- Интеграционные тесты слоя `data`: проверка уникальности `telegram_id`.
- Контрактный тест подтверждения Telegram с моками — гарантирует вызов `UserService.upsertFromTelegram` и передачу результата в дальнейшие шаги.
