# Авторизация

Документ описывает процесс входа в систему, управление сессиями и выдачу прав.

## 1. Термины

- **access-JWT** — короткоживущий JWT, содержащий `sub`, `jti`, `iat`, `exp`.
- **refresh-токен** — токен в httpOnly-куке, используемый для получения нового access-JWT.
- **jti** — идентификатор сессии; используется в ключах `sess:{jti}` и `blk:{jti}`.
- **capVersion** — версия прав пользователя для синхронизации и проверки актуальности.

## 2. Цели

- Выдать короткоживущий access-JWT.
- Создать/обновить серверную сессию в кеше (`sess:{jti}` с TTL ≈ время жизни access + δ).
- Вернуть клиенту набор прав по активной семье.
- Минимизировать содержимое JWT.

## 3. Сценарии входа

### 3.1 Первичный вход через Telegram Login
Пользователь подтверждает свою личность через Telegram. Создаётся новый пользователь (при необходимости), сессия и выдаётся access-JWT.

### 3.2 Обновление access по refresh-токену
Клиент отправляет refresh-токен (в httpOnly-куке); сервер выдаёт новый access-JWT и ротирует `jti`.

### 3.3 Смена активной семьи
Пользователь переключает контекст на другую семью, права пересчитываются без повторной аутентификации.

### 3.4 Выход
Сессия удаляется, `jti` помещается в `blk:{jti}` до истечения срока.

## 4. Контракты API

Ответы ошибок имеют вид:

```json
{ "error": "CODE", "message": "Описание" }
```

### 4.1 `POST /auth/telegram/verify`
Проверяет подпись Telegram и создаёт сессию.

Пример запроса:

```json
{
  "id": 123456789,
  "first_name": "Vasiliy",
  "username": "vas",
  "photo_url": "https://t.me/i/userpic/...",
  "auth_date": 1734970000,
  "hash": "b74f..."
}
```

Успешный ответ:

```json
{
  "accessToken": "jwt",
  "expiresIn": 900,
  "user": { "id": "u-123", "name": "Vasiliy" },
  "activeFamilyId": "f-456",
  "scopes": ["media:list","media:download","tree:read"],
  "refreshTokenSet": true
}
```

Ошибки: `401 INVALID_TELEGRAM_SIGNATURE`, `400 STALE_AUTH_DATE`, `429 TOO_MANY_ATTEMPTS`.

### 4.2 `POST /auth/refresh`
Выдаёт новый access-JWT по refresh-токену, создаёт `sess:{jtiNew}` и добавляет старый `jti` в `blk:{jtiOld}`.

Пример ответа идентичен `POST /auth/telegram/verify`.

### 4.3 `POST /me/active-family`
Переключает активную семью.

Запрос:

```json
{ "familyId": "f-789" }
```

Ответ:

```json
{
  "accessToken": "jwt",
  "expiresIn": 900,
  "activeFamilyId": "f-789",
  "scopes": ["media:list","media:download"]
}
```

Ошибки: `403 NO_MEMBERSHIP`, `404 FAMILY_NOT_FOUND`.

### 4.4 `POST /auth/logout`
Удаляет текущую сессию и помещает `jti` в `blk:{jti}`.

Ответ `204 No Content`.

## 5. Алгоритм проверки Telegram

1. Исключить поле `hash` и сформировать строки `key=value`, отсортированные по ключу, затем соединить через `\n`.
2. Посчитать `SHA256` от `bot_token` — это секрет для HMAC.
3. Вычислить `HMAC-SHA256` от сформированной строки и сравнить с `hash` (с постоянным временем сравнения).
4. Проверить `auth_date` — оно должно быть не старше 5 минут от времени сервера, что защищает от повторов.
5. Найти или создать пользователя по `telegram_id`.
6. Определить активную семью и загрузить `perm:{userId}:{familyId}` со списком прав и `capVersion`.
7. Сгенерировать `jti`, записать `sess:{jti}` и выдать access-JWT и refresh-токен.

## 6. Структура access-JWT

Пример содержимого:

```json
{
  "sub": "u-123",
  "jti": "sess-abc",
  "iat": 1734970000,
  "exp": 1734970900
}
```

JWT подписывается `RS256` или `ES256`, размер — не более 2 КБ. При каждом запросе проверяются подпись и срок действия. По `jti` ищется `sess:{jti}` в Redis; при отсутствии выполняется одно резервное обращение к БД.

## 7. Поток обновления токена

Refresh-токен хранится в cookie с флагами `httpOnly`, `Secure`, `SameSite=Lax/Strict` и сроком жизни 7–30 дней (компромисс между удобством и безопасностью). При обновлении:

1. Проверяется валидность и отзыв.
2. Генерируется новый `jti` и новый access-JWT.
3. `sess:{jti}` пересоздаётся из `perm:{userId}:{familyId}`.
4. Старый `jti` добавляется в `blk:{jtiOld}` до истечения `exp`.

При утрате refresh-токена требуется повторный вход через Telegram.

## 8. Смена активной семьи

1. Проверить, что у пользователя есть членство в `familyId`.
2. Загрузить пресеты прав из БД и обновить `perm:{userId}:{familyId}`.
3. Обновить `sess:{jti}` (активная семья, права, `capVersion`) и выдать новый access-JWT.

## 9. Обновление прав в реальном времени

- **Push-оповещение**: при изменении ролей система находит активные `jti` пользователя и обновляет соответствующие `sess:{jti}`.
- **Ленивая проверка**: при запросе сравнивается локальный `capVersion` с версией в `sess:{jti}`; при расхождении сессия пересобирается.

## 10. Безопасность и ограничения

- Ограничение частоты на `/auth/telegram/verify`, например 5 попыток в минуту на IP или `telegram_id`.
- Защита от повторов: окно для `auth_date` и одноразовость набора данных (`used_hash:{hash}` с TTL несколько минут).
- Аудит: логирование успешных и неуспешных входов, смены семьи, обновлений и выходов в централизованном журнале.
- При отказе кэша допускается одно резервное обращение к БД, затем возврат `503` или `403`.
- CORS/CSRF: access передаётся в заголовке `Authorization`; обновление — через refresh-токен в cookie и при необходимости токен двойной отправки.

## 11. Открытые вопросы

- Окно допустимого `auth_date`.
- TTL access-JWT.
- Стратегия ротации refresh-токена.
- Выбор первой активной семьи.
- Механизм хранения индекса `index:user:{userId} → [jti...]` для массового отзыва.

Приглашаем команду к обсуждению этих пунктов.
